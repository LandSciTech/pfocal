% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pfocal_fast.R
\name{fast_pfocal_gaussian_radius}
\alias{fast_pfocal_gaussian_radius}
\alias{fast_pfocal_gaussian_confidence}
\alias{fast_pfocal_binomial}
\alias{fast_pfocal_abs_rectangle}
\alias{fast_pfocal_separated}
\title{Fast methods for common kernel computations}
\usage{
fast_pfocal_gaussian_radius(
  data,
  vertical_radius,
  vertical_sd = 1,
  horizontal_radius = vertical_radius,
  horizontal_sd = vertical_sd,
  tail_included = TRUE,
  na.rm = NA,
  mp = TRUE,
  debug_use_r_implementation = FALSE,
  ...,
  transform_function = "MULTIPLY",
  reduce_function = "SUM",
  mean_divider = "ONE",
  variance = FALSE
)

fast_pfocal_gaussian_confidence(
  data,
  vertical_r0 = 0.05,
  vertical_sd = 1,
  horizontal_r0 = vertical_r0,
  horizontal_sd = vertical_sd,
  tail_included = TRUE,
  na.rm = NA,
  mp = TRUE,
  debug_use_r_implementation = FALSE,
  ...,
  transform_function = "MULTIPLY",
  reduce_function = "SUM",
  mean_divider = "ONE",
  variance = FALSE
)

fast_pfocal_binomial(
  data,
  vertical_radius,
  horizontal_radius = vertical_radius,
  na.rm = NA,
  mp = TRUE,
  debug_use_r_implementation = FALSE,
  ...,
  transform_function = "MULTIPLY",
  reduce_function = "SUM",
  mean_divider = "ONE",
  variance = FALSE
)

fast_pfocal_abs_rectangle(
  data,
  height,
  width = height,
  value = 1,
  na.rm = NA,
  mp = TRUE,
  debug_use_r_implementation = FALSE,
  ...,
  transform_function = "MULTIPLY",
  reduce_function = "SUM",
  mean_divider = "ONE",
  variance = FALSE
)

fast_pfocal_separated(
  data,
  kernel_list,
  na.rm = NA,
  mp = TRUE,
  debug_use_r_implementation = FALSE,
  ...,
  transform_function = "MULTIPLY",
  reduce_function = "SUM",
  mean_divider = "ONE",
  variance = FALSE
)
}
\arguments{
\item{data}{\strong{[matrix-type]} Grid to compute onto.}

\item{vertical_radius}{\strong{[numeric]} The kernel's radius in the vertical
dimension.}

\item{vertical_sd}{\strong{[numeric]} The kernel's standard deviation in the
vertical dimension.}

\item{horizontal_radius}{\strong{[numeric]} The kernel's radius in the horizontal
dimension.}

\item{horizontal_sd}{\strong{[numeric]} The kernel's standard deviation in the
horizontal dimension.}

\item{tail_included}{\strong{[logical]} TODO}

\item{na.rm}{\strong{[NA OR character]} The behavior to adopt for dealing with
missing values, default to \code{NA}. Far possible values see
\code{\link[=pfocal_nan_policy_info]{pfocal_nan_policy_info()}}.}

\item{mp}{\strong{[logical]} Whether to use the open_mp implementation,
default to \code{TRUE}.}

\item{debug_use_r_implementation}{\strong{[logical]} Used for debugging purposes
whether to use the slow R implementation instead of the fass C++ code.
Default to \code{FALSE}.}

\item{...}{None used.}

\item{transform_function}{\strong{[character]} The function to apply to the
cell values covered by the kernel. For possible values, see
\code{\link[=pfocal_transform_info]{pfocal_transform_info()}}. Default to \code{"MULTIPLY"}.}

\item{reduce_function}{\strong{[character]} The function to apply to the kernel
values after the function passed in \code{transform_function} has been applied
(the function that summarize the data). For possible values, see
\code{\link[=pfocal_reduce_info]{pfocal_reduce_info()}}. Default to \code{"SUM"}.}

\item{mean_divider}{\strong{[character]} Optional, allows to specify how the
final value at each cell is divided by a value that can be function of
the intermediate data resulting of applying \code{transform_function}. For
possible values, see \code{\link[=pfocal_mean_divisor_info]{pfocal_mean_divisor_info()}}. Default to "ONE" (for
no division).}

\item{variance}{\strong{[logical]} Whether to return the "variance" of the
intermediate values at each point (for more details please see
\code{\link[=pfocal_variance_info]{pfocal_variance_info()}}). Default to \code{FALSE} (just returns the value
at each point).}

\item{vertical_r0}{\strong{[numeric]} The kernel's r0 (exponential) in the
vertical dimension.}

\item{horizontal_r0}{\strong{[numeric]} The kernel's r0 (exponential) in the
horizontal dimension.}

\item{height}{\strong{[numeric]} For rectangular kernels, the height of the
rectangle.}

\item{width}{\strong{[numeric]} For rectangular kernels, the width of the
rectangle.}

\item{value}{\strong{[numeric]} For single value matrices, the value.}

\item{kernel_list}{\strong{[list]} A list of kernels computed from functions in
\link{kernel-gaussian}, \link{kernel-binomial}, \link{kernel-circular},
\link{kernel-distance}, \link{kernel-exponential}.}
}
\value{
The updated, convoluted grid.
}
\description{
Methods wrapping \link{pfocal} to implement common kernel computations with
default argument values.
}
\examples{

data <- matrix(nrow = 10, ncol = 10, data = runif(10 * 10))

fast_pfocal_gaussian_radius(data, vertical_radius = 2)
fast_pfocal_gaussian_confidence(data)
fast_pfocal_binomial(data, vertical_radius = 2)
fast_pfocal_abs_rectangle(data, height = 2)

fast_pfocal_separated(data, 
                      kernel_list = list(binomial_kernel(vertical_radius = 2, 
                                                         horizontal_radius = 2), 
                                         distance_kernel(vertical_radius = 2,
                                                         horizontal_radius = 2)))

}
